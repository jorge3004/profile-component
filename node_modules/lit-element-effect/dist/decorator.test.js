"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decorator_1 = require("./decorator");
function createEffect() {
    return {
        on: jest.fn(),
        observe: [],
    };
}
describe("decorator", () => {
    let litElement;
    beforeEach(() => {
        jest.resetAllMocks();
        litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn(),
            updated: () => jest.fn(),
        };
    });
    it("failes for a element without required functions", () => {
        expect(() => (0, decorator_1.decorate)({})).toThrowError("Element missing required functions (dispatchEvent/requestUpdate)");
    });
    it("decorates a litelement with a list for the effects", () => {
        (0, decorator_1.decorate)(litElement);
        expect(litElement.__registered_effects).toBeDefined();
    });
    it("does not re-decorate a litelement if already decorated", () => {
        const decorated = (0, decorator_1.decorate)(litElement);
        decorated.__registered_effects.index = 5;
        (0, decorator_1.decorate)(decorated);
        expect(decorated.__registered_effects.index).toBe(5);
    });
    describe("with effects", () => {
        it("correctly adds the effect to the decoration", () => {
            const effect = createEffect();
            (0, decorator_1.withEffect)(litElement, effect);
            expect(litElement.__registered_effects.effects).toHaveLength(1);
            expect(litElement.__registered_effects.count).toBe(1);
            expect(litElement.__registered_effects.index).toBe(1);
        });
        it("resets the effects on updated, returning the first element again", () => {
            const effect = createEffect();
            (0, decorator_1.withEffect)(litElement, effect);
            expect(litElement.__registered_effects.index).toBe(1);
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect(litElement.__registered_effects.index).toBe(0);
            const resolvedEffect = (0, decorator_1.withEffect)(litElement, createEffect());
            expect(litElement.__registered_effects.count).toBe(1);
            expect(effect).toBe(resolvedEffect);
        });
        it("resets the effects on updated, returning the correct effects on future calls", () => {
            const firstEffect = createEffect();
            const secondEffect = createEffect();
            const thirdEffect = createEffect();
            (0, decorator_1.withEffect)(litElement, firstEffect);
            (0, decorator_1.withEffect)(litElement, secondEffect);
            (0, decorator_1.withEffect)(litElement, thirdEffect);
            expect(litElement.__registered_effects.index).toBe(3);
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect(litElement.__registered_effects.index).toBe(0);
            expect(firstEffect).toBe((0, decorator_1.withEffect)(litElement, createEffect()));
            expect(secondEffect).toBe((0, decorator_1.withEffect)(litElement, createEffect()));
            expect(thirdEffect).toBe((0, decorator_1.withEffect)(litElement, createEffect()));
        });
    });
});
//# sourceMappingURL=decorator.test.js.map