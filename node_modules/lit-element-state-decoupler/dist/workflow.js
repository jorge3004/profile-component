"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useWorkflow = void 0;
const _1 = require(".");
const decorator_1 = require("./decorator");
const useWorkflow = (element, reducers) => {
    const innerReducers = Object.entries(reducers).reduce((prev, [projection, { reducer, initialState }]) => (prev[projection] = (0, _1.useReducer)(element, reducer, initialState), prev), {});
    const sideeffect = {};
    const compensations = {};
    const workflowHistory = [];
    const projections = (key) => {
        workflowHistory.push({
            type: "projections",
            args: [key]
        });
        return (innerReducers[key]) ? innerReducers[key].get() : undefined;
    };
    const addActivity = (activity, data) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        workflowHistory.push({
            type: "addActivity",
            args: [activity, data]
        });
        yield Promise.all((_b = (_a = sideeffect[activity]) === null || _a === void 0 ? void 0 : _a.map(effect => effect(data))) !== null && _b !== void 0 ? _b : []);
        for (const reducer of Object.values(innerReducers)) {
            yield reducer.dispatch(activity, data);
        }
    });
    const addCompensation = (activity, data) => {
        workflowHistory.push({
            type: "addCompensation",
            args: [activity, data]
        });
        compensations[activity] = [
            ...(compensations[activity] || []),
            data
        ];
    };
    const addSideeffect = (activity, effect) => {
        workflowHistory.push({
            type: "addSideeffect",
            args: [activity, effect]
        });
        sideeffect[activity] = [
            ...(sideeffect[activity] || []),
            effect
        ];
    };
    const compensate = () => __awaiter(void 0, void 0, void 0, function* () {
        workflowHistory.push({
            type: "compensate",
            args: []
        });
        for (const [activity, dataArguments] of Object.entries(compensations)) {
            for (const data of dataArguments) {
                for (const reducer of Object.values(innerReducers)) {
                    yield reducer.dispatch(activity, data);
                }
            }
        }
    });
    const after = (timeout, unlessActivity, execute) => {
        workflowHistory.push({
            type: "after",
            args: [timeout, unlessActivity, execute]
        });
        const compareWorkflow = (entry, unless) => {
            if (entry.type !== unless.type)
                return false;
            for (let arg = 0; arg < unless.args.length; arg++) {
                if (entry.args[arg] !== unless.args[arg])
                    return false;
            }
            return true;
        };
        const check = () => __awaiter(void 0, void 0, void 0, function* () {
            if (workflowHistory.some(entry => compareWorkflow(entry, unlessActivity))) {
                return;
            }
            else if (new Date(Date.now()) > timeout) {
                yield execute();
            }
            else {
                setTimeout(check, 100);
            }
        });
        check();
    };
    const plan = (plan) => __awaiter(void 0, void 0, void 0, function* () {
        for (const [entity, workflow] of Object.entries(plan)) {
            if (reducers[entity] &&
                JSON.stringify(projections(entity)) === JSON.stringify(reducers[entity].initialState)) {
                return yield workflow();
            }
        }
        return plan[""]
            ? yield plan[""]()
            : Promise.resolve(null);
    });
    return (0, decorator_1.withWorkflow)(element, {
        addActivity,
        addSideeffect,
        projections,
        addCompensation,
        compensate,
        after,
        plan,
        history: () => [...workflowHistory]
    });
};
exports.useWorkflow = useWorkflow;
//# sourceMappingURL=workflow.js.map