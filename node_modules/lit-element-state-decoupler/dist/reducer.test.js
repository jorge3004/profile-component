"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const reducer_1 = require("./reducer");
const decorator_1 = require("./decorator");
class StateExample {
    constructor(value = "true") {
        this.value = value;
    }
}
const exampleReducer = (state) => ({
    changeValue: (payload) => (Promise.resolve(Object.assign(Object.assign({}, state), { value: payload }))),
    otherAction: (payload) => (Promise.resolve(Object.assign(Object.assign({}, state), { value: payload })))
});
describe("Reducer", () => {
    let reducer;
    const litElement = {
        requestUpdate: jest.fn(),
        dispatchEvent: jest.fn()
    };
    const initialState = { value: "bla", other: "blub" };
    beforeEach(() => {
        jest.resetAllMocks();
        reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
    });
    it("sets up the default state", () => {
        expect(reducer.get()).toEqual(initialState);
        expect(reducer.get()).not.toBe(initialState);
    });
    describe("when triggering an existing action", () => {
        const subscriber = jest.fn();
        const when = jest.fn();
        let currentState;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            reducer.subscribe(subscriber);
            reducer.when("changeValue", when);
            currentState = reducer.get();
            yield reducer.set("changeValue", "lala");
            yield reducer.set("otherAction", "blablub");
        }));
        it("updates the state", () => {
            expect(reducer.get()).toEqual(Object.assign(Object.assign({}, currentState), { value: "blablub" }));
            expect(reducer.get()).not.toBe(currentState);
        });
        it("notifies any subscriber", () => {
            expect(subscriber).toBeCalledTimes(2);
            expect(subscriber).toBeCalledWith("changeValue", Object.assign(Object.assign({}, currentState), { value: "lala" }));
            expect(subscriber).toBeCalledWith("otherAction", Object.assign(Object.assign({}, currentState), { value: "blablub" }));
        });
        it("notifies any when", () => {
            expect(when).toBeCalledTimes(1);
            expect(when).toBeCalledWith(Object.assign(Object.assign({}, currentState), { value: "lala" }));
        });
        it("refreshes the owning component every time", () => {
            expect(litElement.requestUpdate).toBeCalledTimes(2);
        });
        it("dispatches a custom event if specfied in the options", () => __awaiter(void 0, void 0, void 0, function* () {
            const reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState, { dispatchEvent: true });
            yield reducer.set("changeValue", "lala");
            expect(litElement.dispatchEvent).toBeCalledTimes(1);
            const detail = reducer.get();
            expect(litElement.dispatchEvent).toBeCalledWith(new CustomEvent("changeValue", { detail }));
            expect(litElement.dispatchEvent.mock.calls[0][0].detail).toEqual(detail);
        }));
    });
    describe("when triggering a non-existing action", () => {
        const subscriber = jest.fn();
        let currentState;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            reducer.subscribe(subscriber);
            currentState = reducer.get();
            yield reducer.set("notexisting", "lala");
        }));
        it("doesn't update the state", () => {
            expect(reducer.get()).toEqual(currentState);
            expect(reducer.get()).toBe(currentState);
        });
        it("doesn't notify any subscriber", () => {
            expect(subscriber).not.toBeCalled();
        });
        it("doesn't refresh the owning component", () => {
            expect(litElement.requestUpdate).not.toBeCalled();
        });
        it("doesn't dispatch a custom event if specfied in the options", () => __awaiter(void 0, void 0, void 0, function* () {
            const reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState, { dispatchEvent: true });
            yield reducer.set("notexisting", "lala");
            expect(litElement.dispatchEvent).toBeCalledTimes(0);
        }));
    });
});
describe("reducer - when overriding defaults", () => {
    let reducer;
    let litElement;
    const initialState = { value: "bla", other: "blub" };
    beforeEach(() => {
        jest.resetAllMocks();
        litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn(),
            updated: jest.fn()
        };
    });
    it("should update the defaults on every call", () => {
        reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState, { updateDefault: true });
        expect(reducer.get()).toEqual(initialState);
        reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, Object.assign(Object.assign({}, initialState), { value: "changed" }), { updateDefault: true });
        expect(reducer.get()).toEqual(Object.assign(Object.assign({}, initialState), { value: "changed" }));
    });
});
describe("reducer - reducer registration", () => {
    let reducer;
    let litElement;
    const initialState = { value: "bla", other: "blub" };
    beforeEach(() => {
        jest.resetAllMocks();
        litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn(),
            updated: jest.fn()
        };
        reducer = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
    });
    it("should retrieve the same reducer after an update", () => {
        (0, decorator_1.asUpdateableLitElement)(litElement).updated();
        const reducer1 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        (0, decorator_1.asUpdateableLitElement)(litElement).updated();
        const reducer2 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        expect(reducer1).toBe(reducer2);
        expect(reducer).toBe(reducer2);
    });
    it("should add multiple reducers between updates", () => {
        const reducer1 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        const reducer2 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        (0, decorator_1.asUpdateableLitElement)(litElement).updated();
        const retrieved0 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        const retrieved1 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        const retrieved2 = (0, reducer_1.useReducer)(litElement, exampleReducer, initialState);
        (0, decorator_1.asUpdateableLitElement)(litElement).updated();
        expect(retrieved0).toBe(reducer);
        expect(reducer1).toBe(retrieved1);
        expect(reducer2).toBe(retrieved2);
    });
});
//# sourceMappingURL=reducer.test.js.map