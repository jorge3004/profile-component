"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withWorkflow = exports.withReducer = exports.withState = exports.decorate = exports.asUpdateableLitElement = void 0;
function asUpdateableLitElement(element) {
    if (!element.dispatchEvent || !element.requestUpdate)
        throw new Error("Element missing required functions (dispatchEvent/requestUpdate)");
    return element;
}
exports.asUpdateableLitElement = asUpdateableLitElement;
const reservedField = "__registered_states";
function decorate(litElement) {
    const decoratedLitElement = litElement;
    if (decoratedLitElement[reservedField])
        return decoratedLitElement;
    const updateableLitLikeElement = asUpdateableLitElement(litElement);
    const oldUpdated = updateableLitLikeElement.updated;
    decoratedLitElement[reservedField] = {
        index: 0,
        count: 0,
        states: [],
        reducers: [],
        workflows: []
    };
    updateableLitLikeElement.updated = (args) => {
        decoratedLitElement[reservedField].index = 0;
        return oldUpdated(args);
    };
    return decoratedLitElement;
}
exports.decorate = decorate;
function withState(litElement, state, options = {}) {
    const decoratedLitElement = decorate(litElement);
    const { index, count } = decoratedLitElement[reservedField];
    if (index === count) {
        decoratedLitElement[reservedField].index++;
        decoratedLitElement[reservedField].count++;
        decoratedLitElement[reservedField].states.push(state);
        return state;
    }
    decoratedLitElement[reservedField].index++;
    if (options.updateDefault)
        decoratedLitElement[reservedField].states[index].inject(state.get());
    return decoratedLitElement[reservedField].states[index];
}
exports.withState = withState;
function withReducer(litElement, reduce) {
    const decoratedLitElement = decorate(litElement);
    const { index, count, reducers } = decoratedLitElement[reservedField];
    if (index === count && !reducers[index - 1]) {
        decoratedLitElement[reservedField].reducers[index - 1] = reduce;
        return reduce;
    }
    return decoratedLitElement[reservedField].reducers[index - 1];
}
exports.withReducer = withReducer;
function withWorkflow(litElement, workflow) {
    const decoratedLitElement = decorate(litElement);
    const { index, count, workflows } = decoratedLitElement[reservedField];
    if (index === count && !workflows[index - 1]) {
        decoratedLitElement[reservedField].workflows[index - 1] = workflow;
        return workflow;
    }
    return decoratedLitElement[reservedField].workflows[index - 1];
}
exports.withWorkflow = withWorkflow;
//# sourceMappingURL=decorator.js.map