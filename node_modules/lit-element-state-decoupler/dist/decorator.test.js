"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decorator_1 = require("./decorator");
function createState() {
    return {
        set: jest.fn(),
        subscribe: jest.fn(),
        get: jest.fn(),
        inject: jest.fn(),
        value: jest.fn()
    };
}
function createReducer() {
    return {
        when: jest.fn(),
        set: jest.fn(),
        subscribe: jest.fn(),
        get: jest.fn(),
        dispatch: jest.fn()
    };
}
function createWorkflow() {
    return {
        addActivity: jest.fn(),
        addCompensation: jest.fn(),
        addSideeffect: jest.fn(),
        projections: jest.fn(),
        history: jest.fn(),
        after: jest.fn(),
        compensate: jest.fn(),
        plan: jest.fn()
    };
}
describe("decorator", () => {
    let litElement;
    beforeEach(() => {
        jest.resetAllMocks();
        litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn(),
            updated: () => jest.fn(),
        };
    });
    it("failes for a element without required functions", () => {
        expect(() => (0, decorator_1.decorate)({})).toThrowError("Element missing required functions (dispatchEvent/requestUpdate)");
    });
    it("decorates a litelement with a list for the states", () => {
        (0, decorator_1.decorate)(litElement);
        expect(litElement.__registered_states).toBeDefined();
    });
    it("does not re-decorate a litelement if already decorated", () => {
        const decorated = (0, decorator_1.decorate)(litElement);
        decorated.__registered_states.index = 5;
        (0, decorator_1.decorate)(decorated);
        expect(decorated.__registered_states.index).toBe(5);
    });
    describe("with states", () => {
        it("correctly adds the state to the decoration", () => {
            const state = createState();
            (0, decorator_1.withState)(litElement, state);
            expect(litElement.__registered_states.states).toHaveLength(1);
            expect(litElement.__registered_states.count).toBe(1);
            expect(litElement.__registered_states.index).toBe(1);
        });
        it("resets the states on updated, returning the first element again", () => {
            const state = createState();
            state.get.mockReturnValue("state 1");
            (0, decorator_1.withState)(litElement, state);
            expect(litElement.__registered_states.index).toBe(1);
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect(litElement.__registered_states.index).toBe(0);
            const secondState = createState();
            secondState.get.mockReturnValue("state 2");
            const resolvedState = (0, decorator_1.withState)(litElement, secondState);
            expect(litElement.__registered_states.count).toBe(1);
            expect(state).toBe(resolvedState);
            expect(state.get()).toBe(resolvedState.get());
        });
        it("uses the new default state the states on updated if requested, still returning the first element", () => {
            const state = createState();
            state.get.mockReturnValue("state 1");
            (0, decorator_1.withState)(litElement, state);
            expect(litElement.__registered_states.index).toBe(1);
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect(litElement.__registered_states.index).toBe(0);
            const secondState = createState();
            secondState.get.mockReturnValue("state 2");
            const resolvedState = (0, decorator_1.withState)(litElement, secondState, { updateDefault: true });
            expect(litElement.__registered_states.count).toBe(1);
            expect(state).toBe(resolvedState);
            expect(state.inject).toBeCalledWith(secondState.get());
        });
        it("resets the states on updated, returning the correct states on future calls", () => {
            const firstState = createState();
            const secondState = createState();
            const thirdState = createState();
            (0, decorator_1.withState)(litElement, firstState);
            (0, decorator_1.withState)(litElement, secondState);
            (0, decorator_1.withState)(litElement, thirdState);
            expect(litElement.__registered_states.index).toBe(3);
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect(litElement.__registered_states.index).toBe(0);
            expect(firstState).toBe((0, decorator_1.withState)(litElement, createState()));
            expect(secondState).toBe((0, decorator_1.withState)(litElement, createState()));
            expect(thirdState).toBe((0, decorator_1.withState)(litElement, createState()));
        });
    });
    describe("with reducers, which work only together with states", () => {
        beforeEach(() => {
            // reducers only exist as part of states, 
            //  which is why we always have to create one first
            (0, decorator_1.withState)(litElement, createState());
        });
        it("correctly adds the reducer when we are still adding elements", () => {
            expect(litElement.__registered_states.reducers).toHaveLength(0);
            (0, decorator_1.withReducer)(litElement, createReducer());
            expect(litElement.__registered_states.reducers).toHaveLength(1);
        });
        it("correctly adds the reducer at the right index when we are still adding elements", () => {
            (0, decorator_1.withState)(litElement, createState());
            (0, decorator_1.withState)(litElement, createState());
            expect(litElement.__registered_states.reducers).toHaveLength(0);
            const currentReducer = (0, decorator_1.withReducer)(litElement, createReducer());
            expect(litElement.__registered_states.reducers[0]).toBeUndefined();
            expect(litElement.__registered_states.reducers[1]).toBeUndefined();
            expect(litElement.__registered_states.reducers[2]).toBe(currentReducer);
            expect(litElement.__registered_states.reducers).toHaveLength(3);
        });
        it("correctly gets the reducer after an update", () => {
            (0, decorator_1.withState)(litElement, createState());
            const middleReducer = (0, decorator_1.withReducer)(litElement, createReducer());
            (0, decorator_1.withState)(litElement, createState());
            const lastReducer = (0, decorator_1.withReducer)(litElement, createReducer());
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect((0, decorator_1.withReducer)(litElement, createReducer())).toBeUndefined();
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withReducer)(litElement, createReducer())).toBeUndefined();
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withReducer)(litElement, createReducer())).toBe(middleReducer);
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withReducer)(litElement, createReducer())).toBe(lastReducer);
        });
    });
    describe("with workflows, which work only together with states", () => {
        beforeEach(() => {
            // workflows only exist as part of states, 
            //  which is why we always have to create one first
            (0, decorator_1.withState)(litElement, createState());
        });
        it("correctly adds the workflow when we are still adding elements", () => {
            expect(litElement.__registered_states.workflows).toHaveLength(0);
            (0, decorator_1.withWorkflow)(litElement, createWorkflow());
            expect(litElement.__registered_states.workflows).toHaveLength(1);
        });
        it("correctly adds the workflow at the right index when we are still adding elements", () => {
            (0, decorator_1.withState)(litElement, createState());
            (0, decorator_1.withState)(litElement, createState());
            expect(litElement.__registered_states.workflows).toHaveLength(0);
            const currentWorkflow = (0, decorator_1.withWorkflow)(litElement, createWorkflow());
            expect(litElement.__registered_states.workflows[0]).toBeUndefined();
            expect(litElement.__registered_states.workflows[1]).toBeUndefined();
            expect(litElement.__registered_states.workflows[2]).toBe(currentWorkflow);
            expect(litElement.__registered_states.workflows).toHaveLength(3);
        });
        it("correctly gets the workflow after an update", () => {
            (0, decorator_1.withState)(litElement, createState());
            const middleWorkflow = (0, decorator_1.withWorkflow)(litElement, createWorkflow());
            (0, decorator_1.withState)(litElement, createState());
            const lastWorkflow = (0, decorator_1.withWorkflow)(litElement, createWorkflow());
            (0, decorator_1.asUpdateableLitElement)(litElement).updated();
            expect((0, decorator_1.withWorkflow)(litElement, createWorkflow())).toBeUndefined();
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withWorkflow)(litElement, createWorkflow())).toBeUndefined();
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withWorkflow)(litElement, createWorkflow())).toBe(middleWorkflow);
            (0, decorator_1.withState)(litElement, createState());
            expect((0, decorator_1.withWorkflow)(litElement, createWorkflow())).toBe(lastWorkflow);
        });
    });
});
//# sourceMappingURL=decorator.test.js.map