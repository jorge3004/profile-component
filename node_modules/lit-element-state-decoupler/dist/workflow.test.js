"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const workflow_1 = require("./workflow");
class Rejection {
    constructor(code, message, state) {
        this.code = code;
        this.message = message;
        this.state = state;
    }
    toString() {
        return `[${this.code}] ${this.message}`;
    }
}
const notFound = (who, state) => (console.log(`${who} not found`, state), new Rejection("NOT_FOUND", `${who} not found`, state));
const conflict = (who, state) => (console.log(`${who} already exists`, state), new Rejection("CONFLICT", `${who} already exists`, state));
const customersReducer = (state) => ({
    createCustomer: (userName) => {
        return new Promise((resolve, reject) => {
            if (state.some(customer => customer.userName === userName))
                return reject(conflict("User", state));
            return resolve([...state, { userName }]);
        });
    },
    changeCustomerName: ({ oldName, userName }) => new Promise((resolve, reject) => {
        const index = state.findIndex((customer) => customer.userName === oldName);
        if (index < 0)
            return reject(notFound("User", state));
        state[index] = Object.assign(Object.assign({}, state[index]), { userName });
        return resolve([...state]);
    }),
    deleteCustomer: (userName) => new Promise((resolve, reject) => {
        const index = state.findIndex((customer) => customer.userName === userName);
        if (index < 0)
            return (reject(notFound("User", state)));
        state.splice(index, 1);
        return resolve([...state]);
    })
});
const contractReducer = (state) => ({
    createContract: ({ contractNumber, userName, runtime }) => new Promise((resolve, reject) => {
        if (state.some(contract => contract.contractNumber === contractNumber))
            return reject(conflict("Contract", state));
        const created = new Date(Date.now());
        // contract always starts at the beginning of the month
        created.setDate(1);
        const ends = new Date(created);
        ends.setMonth(ends.getMonth() + runtime);
        return resolve([
            ...state,
            { contractNumber, userName: userName, created, ends }
        ]);
    }),
    changeCustomerName: ({ oldName, userName }) => new Promise((resolve) => resolve(state.map(contract => (contract.userName === oldName) ? Object.assign(Object.assign({}, contract), { userName }) : contract))),
    removeContract: (contractNumber) => new Promise((resolve, reject) => {
        const index = state.findIndex(contract => contract.contractNumber === contractNumber);
        if (index < 0)
            return reject(notFound("Contract", state));
        state.splice(index, 1);
        return resolve([...state]);
    })
});
describe("Given I have a workflow", () => {
    let workflow;
    beforeEach(() => {
        jest.resetAllMocks();
        const litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn()
        };
        workflow = (0, workflow_1.useWorkflow)(litElement, {
            customers: { reducer: customersReducer, initialState: [] },
            contracts: { reducer: contractReducer, initialState: [] }
        });
    });
    it("returns undefined for non-existing projections (probably a bad idea, let's think about something better)", () => {
        expect(workflow.projections("made up")).toEqual(undefined);
    });
    it("executes every step when all go well", () => __awaiter(void 0, void 0, void 0, function* () {
        let userName = "Mustermann";
        yield workflow.addActivity("createCustomer", userName);
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([]);
        const contractNumber = 1;
        yield workflow.addActivity("createContract", { userName, contractNumber, runtime: 3 });
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        userName = "Klaus";
        yield workflow.addActivity("changeCustomerName", { oldName: "Mustermann", userName });
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        workflow.addSideeffect("deleteCustomer", (userName) => __awaiter(void 0, void 0, void 0, function* () {
            return yield Promise.all(workflow.projections("contracts")
                .filter(contract => contract.userName === userName)
                .map(({ contractNumber }) => workflow.addActivity("removeContract", contractNumber)));
        }));
        yield workflow.addActivity("deleteCustomer", userName);
        expect(workflow.projections("customers")).toEqual([]);
        expect(workflow.projections("contracts")).toEqual([]);
        expect(workflow.history()).toMatchSnapshot();
    }));
    it("compensates if a step fails", () => __awaiter(void 0, void 0, void 0, function* () {
        let userName = "Mustermann";
        const contractNumber = 1;
        yield workflow.addActivity("createCustomer", userName);
        workflow.addCompensation("deleteCustomer", userName);
        yield workflow.addActivity("createContract", { userName, contractNumber, runtime: 3 });
        workflow.addCompensation("removeContract", contractNumber);
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        // we just want to avoid it gets triggered right away, just for readability
        const days = (_) => {
            const future = new Date();
            future.setMilliseconds(future.getMilliseconds() + 100);
            return future;
        };
        workflow.after(days(1), { type: "confirmedEmail", args: [userName] }, () => __awaiter(void 0, void 0, void 0, function* () { return yield workflow.compensate(); }));
        yield new Promise(resolve => setTimeout(resolve, 500));
        // compensation should have happenend
        expect(workflow.projections("customers")).toEqual([]);
        expect(workflow.projections("contracts")).toEqual([]);
        expect(workflow.history().some(entry => entry.type === "compensate")).toBeTruthy();
    }));
    it("does not compensates if all step pass on a full history match", () => __awaiter(void 0, void 0, void 0, function* () {
        let userName = "Mustermann";
        const contractNumber = 1;
        yield workflow.addActivity("createCustomer", userName);
        workflow.addCompensation("deleteCustomer", userName);
        yield workflow.addActivity("createContract", { userName, contractNumber, runtime: 3 });
        workflow.addCompensation("removeContract", contractNumber);
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        // we want that to be now anyways, just for readability
        const days = (_) => new Date(0);
        // it should not matter if an activity has happened before or after in a workflow
        //  this way we won't have timing issues as after will be executed right away
        yield workflow.addActivity("confirmedEmail", userName);
        workflow.after(days(1), { type: "addActivity", args: ["confirmedEmail", userName] }, () => __awaiter(void 0, void 0, void 0, function* () { return yield workflow.compensate(); }));
        // should not be componsated
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        expect(workflow.history().some(entry => entry.type === "compensate")).toBeFalsy();
    }));
    it("does not compensates if all step pass when checking for the start of a history entry", () => __awaiter(void 0, void 0, void 0, function* () {
        let userName = "Mustermann";
        const contractNumber = 1;
        yield workflow.addActivity("createCustomer", userName);
        workflow.addCompensation("deleteCustomer", userName);
        yield workflow.addActivity("createContract", { userName, contractNumber, runtime: 3 });
        workflow.addCompensation("removeContract", contractNumber);
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        // we want that to be now anyways, just for readability
        const days = (_) => new Date(0);
        // it should not matter if an activity has happened before or after in a workflow
        //  this way we won't have timing issues as after will be executed right away
        yield workflow.addActivity("confirmedEmail", userName);
        workflow.after(days(1), { type: "addActivity", args: ["confirmedEmail"] }, () => __awaiter(void 0, void 0, void 0, function* () { return yield workflow.compensate(); }));
        // should not be componsated
        expect(workflow.projections("customers")).toEqual([{ userName }]);
        expect(workflow.projections("contracts")).toEqual([{ contractNumber, "created": expect.any(Date), "ends": expect.any(Date), userName }]);
        expect(workflow.history().some(entry => entry.type === "compensate")).toBeFalsy();
    }));
});
describe("Given I plan a workflow", () => {
    let workflow;
    beforeEach(() => {
        jest.resetAllMocks();
        const litElement = {
            requestUpdate: jest.fn(),
            dispatchEvent: jest.fn()
        };
        workflow = (0, workflow_1.useWorkflow)(litElement, {
            customers: { reducer: customersReducer, initialState: [] },
            contracts: { reducer: contractReducer, initialState: [] }
        });
    });
    it("executes the plan in the correct order", () => __awaiter(void 0, void 0, void 0, function* () {
        const mockTrace = jest.fn();
        const userName = "name";
        const contractNumber = 1;
        const plan = {
            customers: () => __awaiter(void 0, void 0, void 0, function* () {
                yield workflow.addActivity("createCustomer", userName);
                mockTrace("customer");
                return "customer";
            }),
            contracts: () => __awaiter(void 0, void 0, void 0, function* () {
                yield workflow.addActivity("createContract", { userName, contractNumber, runtime: 3 });
                mockTrace("contracts");
                return "contracts";
            }),
            "": () => __awaiter(void 0, void 0, void 0, function* () {
                mockTrace("done");
                return "done";
            })
        };
        let result = yield workflow.plan(plan);
        yield new Promise(process.nextTick);
        expect(mockTrace.mock.calls[0][0]).toBe("customer");
        result = yield workflow.plan(plan);
        expect(mockTrace.mock.calls[1][0]).toBe("contracts");
        result = yield workflow.plan(plan);
        expect(result).toBe("done");
    }));
    it("finishes a plan with an empty last result if none given", () => __awaiter(void 0, void 0, void 0, function* () {
        const mockTrace = jest.fn();
        const plan = {
            customers: () => __awaiter(void 0, void 0, void 0, function* () {
                yield workflow.addActivity("createCustomer", "name");
                mockTrace("customer");
                return "customer";
            }),
            madeUp: () => __awaiter(void 0, void 0, void 0, function* () { return "made up!"; })
        };
        let result = yield workflow.plan(plan);
        yield new Promise(process.nextTick);
        expect(mockTrace.mock.calls[0][0]).toBe("customer");
        result = yield workflow.plan(plan);
        expect(result).toBe(null);
    }));
});
//# sourceMappingURL=workflow.test.js.map